let wasm;
const { TextDecoder } = require(String.raw`util`);

let WASM_VECTOR_LEN = 0;

let cachegetNodeBufferMemory = null;
function getNodeBufferMemory() {
    if (cachegetNodeBufferMemory === null || cachegetNodeBufferMemory.buffer !== wasm.memory.buffer) {
        cachegetNodeBufferMemory = Buffer.from(wasm.memory.buffer);
    }
    return cachegetNodeBufferMemory;
}

function passStringToWasm(arg) {

    const len = Buffer.byteLength(arg);
    const ptr = wasm.__wbindgen_malloc(len);
    getNodeBufferMemory().write(arg, ptr, len);
    WASM_VECTOR_LEN = len;
    return ptr;
}

let cachegetInt32Memory = null;
function getInt32Memory() {
    if (cachegetInt32Memory === null || cachegetInt32Memory.buffer !== wasm.memory.buffer) {
        cachegetInt32Memory = new Int32Array(wasm.memory.buffer);
    }
    return cachegetInt32Memory;
}

let cachedTextDecoder = new TextDecoder('utf-8', { ignoreBOM: true, fatal: true });

let cachegetUint8Memory = null;
function getUint8Memory() {
    if (cachegetUint8Memory === null || cachegetUint8Memory.buffer !== wasm.memory.buffer) {
        cachegetUint8Memory = new Uint8Array(wasm.memory.buffer);
    }
    return cachegetUint8Memory;
}

function getStringFromWasm(ptr, len) {
    return cachedTextDecoder.decode(getUint8Memory().subarray(ptr, ptr + len));
}

function passArray8ToWasm(arg) {
    const ptr = wasm.__wbindgen_malloc(arg.length * 1);
    getUint8Memory().set(arg, ptr / 1);
    WASM_VECTOR_LEN = arg.length;
    return ptr;
}

function getArrayU8FromWasm(ptr, len) {
    return getUint8Memory().subarray(ptr / 1, ptr / 1 + len);
}

function _assertClass(instance, klass) {
    if (!(instance instanceof klass)) {
        throw new Error(`expected instance of ${klass.name}`);
    }
    return instance.ptr;
}

const heap = new Array(32);

heap.fill(undefined);

heap.push(undefined, null, true, false);

let heap_next = heap.length;

function addHeapObject(obj) {
    if (heap_next === heap.length) heap.push(heap.length + 1);
    const idx = heap_next;
    heap_next = heap[idx];

    heap[idx] = obj;
    return idx;
}

function getObject(idx) { return heap[idx]; }

function dropObject(idx) {
    if (idx < 36) return;
    heap[idx] = heap_next;
    heap_next = idx;
}

function takeObject(idx) {
    const ret = getObject(idx);
    dropObject(idx);
    return ret;
}
/**
* @param {any} input
* @returns {string}
*/
module.exports.uint8array_to_hex = function(input) {
    const retptr = 8;
    const ret = wasm.uint8array_to_hex(retptr, addHeapObject(input));
    const memi32 = getInt32Memory();
    const v0 = getStringFromWasm(memi32[retptr / 4 + 0], memi32[retptr / 4 + 1]).slice();
    wasm.__wbindgen_free(memi32[retptr / 4 + 0], memi32[retptr / 4 + 1] * 1);
    return v0;
};

/**
* Allow to differentiate between address in
* production and testing setting, so that
* one type of address is not used in another setting.
* Example
* ```javascript
* let discriminant = AddressDiscrimination.Test;
* let address = Address::single_from_public_key(public_key, discriminant);
* ```
*/
module.exports.AddressDiscrimination = Object.freeze({ Production:0,Test:1, });
/**
* This is either an single account or a multisig account depending on the witness type
*/
class Account {

    static __wrap(ptr) {
        const obj = Object.create(Account.prototype);
        obj.ptr = ptr;

        return obj;
    }

    free() {
        const ptr = this.ptr;
        this.ptr = 0;

        wasm.__wbg_account_free(ptr);
    }
    /**
    * @param {Address} address
    * @returns {Account}
    */
    static from_address(address) {
        _assertClass(address, Address);
        const ret = wasm.account_from_address(address.ptr);
        return Account.__wrap(ret);
    }
    /**
    * @param {number} discriminant
    * @returns {Address}
    */
    to_address(discriminant) {
        const ret = wasm.account_to_address(this.ptr, discriminant);
        return Address.__wrap(ret);
    }
    /**
    * @param {PublicKey} key
    * @returns {Account}
    */
    static single_from_public_key(key) {
        _assertClass(key, PublicKey);
        const ptr0 = key.ptr;
        key.ptr = 0;
        const ret = wasm.account_single_from_public_key(ptr0);
        return Account.__wrap(ret);
    }
    /**
    * @returns {AccountIdentifier}
    */
    to_identifier() {
        const ret = wasm.account_to_identifier(this.ptr);
        return AccountIdentifier.__wrap(ret);
    }
}
module.exports.Account = Account;
/**
*/
class AccountBindingSignature {

    static __wrap(ptr) {
        const obj = Object.create(AccountBindingSignature.prototype);
        obj.ptr = ptr;

        return obj;
    }

    free() {
        const ptr = this.ptr;
        this.ptr = 0;

        wasm.__wbg_accountbindingsignature_free(ptr);
    }
    /**
    * @param {PrivateKey} private_key
    * @param {TransactionBindingAuthData} auth_data
    * @returns {AccountBindingSignature}
    */
    static new_single(private_key, auth_data) {
        _assertClass(private_key, PrivateKey);
        _assertClass(auth_data, TransactionBindingAuthData);
        const ret = wasm.accountbindingsignature_new_single(private_key.ptr, auth_data.ptr);
        return AccountBindingSignature.__wrap(ret);
    }
}
module.exports.AccountBindingSignature = AccountBindingSignature;
/**
*/
class AccountIdentifier {

    static __wrap(ptr) {
        const obj = Object.create(AccountIdentifier.prototype);
        obj.ptr = ptr;

        return obj;
    }

    free() {
        const ptr = this.ptr;
        this.ptr = 0;

        wasm.__wbg_accountidentifier_free(ptr);
    }
    /**
    * @returns {string}
    */
    to_hex() {
        const retptr = 8;
        const ret = wasm.accountidentifier_to_hex(retptr, this.ptr);
        const memi32 = getInt32Memory();
        const v0 = getStringFromWasm(memi32[retptr / 4 + 0], memi32[retptr / 4 + 1]).slice();
        wasm.__wbindgen_free(memi32[retptr / 4 + 0], memi32[retptr / 4 + 1] * 1);
        return v0;
    }
    /**
    * @returns {Account}
    */
    to_account_single() {
        const ret = wasm.accountidentifier_to_account_single(this.ptr);
        return Account.__wrap(ret);
    }
    /**
    * @returns {Account}
    */
    to_account_multi() {
        const ret = wasm.accountidentifier_to_account_multi(this.ptr);
        return Account.__wrap(ret);
    }
}
module.exports.AccountIdentifier = AccountIdentifier;
/**
* An address of any type, this can be one of
* * A utxo-based address without delegation (single)
* * A utxo-based address with delegation (group)
* * An address for an account
*/
class Address {

    static __wrap(ptr) {
        const obj = Object.create(Address.prototype);
        obj.ptr = ptr;

        return obj;
    }

    free() {
        const ptr = this.ptr;
        this.ptr = 0;

        wasm.__wbg_address_free(ptr);
    }
    /**
    * Construct Address from its bech32 representation
    * Example
    * ```javascript
    * const address = Address.from_string(&#39;ca1q09u0nxmnfg7af8ycuygx57p5xgzmnmgtaeer9xun7hly6mlgt3pjyknplu&#39;);
    * ```
    * @param {string} s
    * @returns {Address}
    */
    static from_string(s) {
        const ret = wasm.address_from_string(passStringToWasm(s), WASM_VECTOR_LEN);
        return Address.__wrap(ret);
    }
    /**
    * Get Address bech32 (string) representation with a given prefix
    * ```javascript
    * let public_key = PublicKey.from_bech32(
    *     &#39;ed25519_pk1kj8yvfrh5tg7n62kdcw3kw6zvtcafgckz4z9s6vc608pzt7exzys4s9gs8&#39;
    * );
    * let discriminant = AddressDiscrimination.Test;
    * let address = Address.single_from_public_key(public_key, discriminant);
    * address.to_string(&#39;ta&#39;)
    * // ta1sj6gu33yw73dr60f2ehp6xemgf30r49rzc25gkrfnrfuuyf0mycgnj78ende550w5njvwzyr20q6rypdea597uu3jnwfltljddl59cseaq7yn9
    * ```
    * @param {string} prefix
    * @returns {string}
    */
    to_string(prefix) {
        const retptr = 8;
        const ret = wasm.address_to_string(retptr, this.ptr, passStringToWasm(prefix), WASM_VECTOR_LEN);
        const memi32 = getInt32Memory();
        const v0 = getStringFromWasm(memi32[retptr / 4 + 0], memi32[retptr / 4 + 1]).slice();
        wasm.__wbindgen_free(memi32[retptr / 4 + 0], memi32[retptr / 4 + 1] * 1);
        return v0;
    }
    /**
    * Construct a single non-account address from a public key
    * ```javascript
    * let public_key = PublicKey.from_bech32(
    *     &#39;ed25519_pk1kj8yvfrh5tg7n62kdcw3kw6zvtcafgckz4z9s6vc608pzt7exzys4s9gs8&#39;
    * );
    * let address = Address.single_from_public_key(public_key, AddressDiscrimination.Test);
    * ```
    * @param {PublicKey} key
    * @param {number} discrimination
    * @returns {Address}
    */
    static single_from_public_key(key, discrimination) {
        _assertClass(key, PublicKey);
        const ptr0 = key.ptr;
        key.ptr = 0;
        const ret = wasm.address_single_from_public_key(ptr0, discrimination);
        return Address.__wrap(ret);
    }
    /**
    * Construct a non-account address from a pair of public keys, delegating founds from the first to the second
    * @param {PublicKey} key
    * @param {PublicKey} delegation
    * @param {number} discrimination
    * @returns {Address}
    */
    static delegation_from_public_key(key, delegation, discrimination) {
        _assertClass(key, PublicKey);
        const ptr0 = key.ptr;
        key.ptr = 0;
        _assertClass(delegation, PublicKey);
        const ptr1 = delegation.ptr;
        delegation.ptr = 0;
        const ret = wasm.address_delegation_from_public_key(ptr0, ptr1, discrimination);
        return Address.__wrap(ret);
    }
    /**
    * Construct address of account type from a public key
    * @param {PublicKey} key
    * @param {number} discrimination
    * @returns {Address}
    */
    static account_from_public_key(key, discrimination) {
        _assertClass(key, PublicKey);
        const ptr0 = key.ptr;
        key.ptr = 0;
        const ret = wasm.address_account_from_public_key(ptr0, discrimination);
        return Address.__wrap(ret);
    }
}
module.exports.Address = Address;
/**
* Amount of the balance in the transaction.
*/
class Balance {

    static __wrap(ptr) {
        const obj = Object.create(Balance.prototype);
        obj.ptr = ptr;

        return obj;
    }

    free() {
        const ptr = this.ptr;
        this.ptr = 0;

        wasm.__wbg_balance_free(ptr);
    }
    /**
    * @returns {any}
    */
    get_sign() {
        const ret = wasm.balance_get_sign(this.ptr);
        return takeObject(ret);
    }
    /**
    * @returns {boolean}
    */
    is_positive() {
        const ret = wasm.balance_is_positive(this.ptr);
        return ret !== 0;
    }
    /**
    * @returns {boolean}
    */
    is_negative() {
        const ret = wasm.balance_is_negative(this.ptr);
        return ret !== 0;
    }
    /**
    * @returns {boolean}
    */
    is_zero() {
        const ret = wasm.balance_is_zero(this.ptr);
        return ret !== 0;
    }
    /**
    * Get value without taking into account if the balance is positive or negative
    * @returns {Value}
    */
    get_value() {
        const ret = wasm.balance_get_value(this.ptr);
        return Value.__wrap(ret);
    }
}
module.exports.Balance = Balance;
/**
* `Block` is an element of the blockchain it contains multiple
* transaction and a reference to the parent block. Alongside
* with the position of that block in the chain.
*/
class Block {

    static __wrap(ptr) {
        const obj = Object.create(Block.prototype);
        obj.ptr = ptr;

        return obj;
    }

    free() {
        const ptr = this.ptr;
        this.ptr = 0;

        wasm.__wbg_block_free(ptr);
    }
    /**
    * Deserialize a block from a byte array
    * @param {any} bytes
    * @returns {Block}
    */
    static from_bytes(bytes) {
        const ret = wasm.block_from_bytes(addHeapObject(bytes));
        return Block.__wrap(ret);
    }
    /**
    * @returns {BlockId}
    */
    id() {
        const ret = wasm.block_id(this.ptr);
        return BlockId.__wrap(ret);
    }
    /**
    * @returns {BlockId}
    */
    parent_id() {
        const ret = wasm.block_parent_id(this.ptr);
        return BlockId.__wrap(ret);
    }
    /**
    *This involves copying all the fragments
    * @returns {Fragments}
    */
    fragments() {
        const ret = wasm.block_fragments(this.ptr);
        return Fragments.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    epoch() {
        const ret = wasm.block_epoch(this.ptr);
        return ret >>> 0;
    }
    /**
    * @returns {number}
    */
    slot() {
        const ret = wasm.block_slot(this.ptr);
        return ret >>> 0;
    }
    /**
    * @returns {number}
    */
    chain_length() {
        const ret = wasm.block_chain_length(this.ptr);
        return ret >>> 0;
    }
    /**
    * @returns {PoolId}
    */
    leader_id() {
        const ret = wasm.block_leader_id(this.ptr);
        return ret === 0 ? undefined : PoolId.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    content_size() {
        const ret = wasm.block_content_size(this.ptr);
        return ret >>> 0;
    }
}
module.exports.Block = Block;
/**
*/
class BlockId {

    static __wrap(ptr) {
        const obj = Object.create(BlockId.prototype);
        obj.ptr = ptr;

        return obj;
    }

    free() {
        const ptr = this.ptr;
        this.ptr = 0;

        wasm.__wbg_blockid_free(ptr);
    }
    /**
    * @returns {Uint8Array}
    */
    as_bytes() {
        const retptr = 8;
        const ret = wasm.blockid_as_bytes(retptr, this.ptr);
        const memi32 = getInt32Memory();
        const v0 = getArrayU8FromWasm(memi32[retptr / 4 + 0], memi32[retptr / 4 + 1]).slice();
        wasm.__wbindgen_free(memi32[retptr / 4 + 0], memi32[retptr / 4 + 1] * 1);
        return v0;
    }
}
module.exports.BlockId = BlockId;
/**
*/
class Certificate {

    static __wrap(ptr) {
        const obj = Object.create(Certificate.prototype);
        obj.ptr = ptr;

        return obj;
    }

    free() {
        const ptr = this.ptr;
        this.ptr = 0;

        wasm.__wbg_certificate_free(ptr);
    }
    /**
    * Create a Certificate for StakeDelegation
    * @param {StakeDelegation} stake_delegation
    * @returns {Certificate}
    */
    static stake_delegation(stake_delegation) {
        _assertClass(stake_delegation, StakeDelegation);
        const ptr0 = stake_delegation.ptr;
        stake_delegation.ptr = 0;
        const ret = wasm.certificate_stake_delegation(ptr0);
        return Certificate.__wrap(ret);
    }
    /**
    * Create a Certificate for PoolRegistration
    * @param {PoolRegistration} pool_registration
    * @returns {Certificate}
    */
    static stake_pool_registration(pool_registration) {
        _assertClass(pool_registration, PoolRegistration);
        const ptr0 = pool_registration.ptr;
        pool_registration.ptr = 0;
        const ret = wasm.certificate_stake_pool_registration(ptr0);
        return Certificate.__wrap(ret);
    }
}
module.exports.Certificate = Certificate;
/**
* Delegation Ratio type express a number of parts
* and a list of pools and their individual parts
*
* E.g. parts: 7, pools: [(A,2), (B,1), (C,4)] means that
* A is associated with 2/7 of the stake, B has 1/7 of stake and C
* has 4/7 of the stake.
*
* It\'s invalid to have less than 2 elements in the array,
* and by extension parts need to be equal to the sum of individual
* pools parts.
*/
class DelegationRatio {

    static __wrap(ptr) {
        const obj = Object.create(DelegationRatio.prototype);
        obj.ptr = ptr;

        return obj;
    }

    free() {
        const ptr = this.ptr;
        this.ptr = 0;

        wasm.__wbg_delegationratio_free(ptr);
    }
    /**
    * @param {number} parts
    * @param {PoolDelegationRatios} pools
    * @returns {DelegationRatio}
    */
    static new(parts, pools) {
        _assertClass(pools, PoolDelegationRatios);
        const ptr0 = pools.ptr;
        pools.ptr = 0;
        const ret = wasm.delegationratio_new(parts, ptr0);
        return ret === 0 ? undefined : DelegationRatio.__wrap(ret);
    }
}
module.exports.DelegationRatio = DelegationRatio;
/**
* Set the choice of delegation:
*
* * No delegation
* * Full delegation of this account to a specific pool
* * Ratio of stake to multiple pools
*/
class DelegationType {

    static __wrap(ptr) {
        const obj = Object.create(DelegationType.prototype);
        obj.ptr = ptr;

        return obj;
    }

    free() {
        const ptr = this.ptr;
        this.ptr = 0;

        wasm.__wbg_delegationtype_free(ptr);
    }
    /**
    * @returns {DelegationType}
    */
    static non_delegated() {
        const ret = wasm.delegationtype_non_delegated();
        return DelegationType.__wrap(ret);
    }
    /**
    * @param {PoolId} pool_id
    * @returns {DelegationType}
    */
    static full(pool_id) {
        _assertClass(pool_id, PoolId);
        const ptr0 = pool_id.ptr;
        pool_id.ptr = 0;
        const ret = wasm.delegationtype_full(ptr0);
        return DelegationType.__wrap(ret);
    }
    /**
    * @param {DelegationRatio} r
    * @returns {DelegationType}
    */
    static ratio(r) {
        _assertClass(r, DelegationRatio);
        const ptr0 = r.ptr;
        r.ptr = 0;
        const ret = wasm.delegationtype_ratio(ptr0);
        return DelegationType.__wrap(ret);
    }
}
module.exports.DelegationType = DelegationType;
/**
* Algorithm used to compute transaction fees
* Currently the only implementation is the Linear one
*/
class Fee {

    static __wrap(ptr) {
        const obj = Object.create(Fee.prototype);
        obj.ptr = ptr;

        return obj;
    }

    free() {
        const ptr = this.ptr;
        this.ptr = 0;

        wasm.__wbg_fee_free(ptr);
    }
    /**
    * Linear algorithm, this is formed by: `coefficient * (#inputs + #outputs) + constant + certificate * #certificate
    * @param {Value} constant
    * @param {Value} coefficient
    * @param {Value} certificate
    * @returns {Fee}
    */
    static linear_fee(constant, coefficient, certificate) {
        _assertClass(constant, Value);
        const ptr0 = constant.ptr;
        constant.ptr = 0;
        _assertClass(coefficient, Value);
        const ptr1 = coefficient.ptr;
        coefficient.ptr = 0;
        _assertClass(certificate, Value);
        const ptr2 = certificate.ptr;
        certificate.ptr = 0;
        const ret = wasm.fee_linear_fee(ptr0, ptr1, ptr2);
        return Fee.__wrap(ret);
    }
    /**
    * @param {Transaction} tx
    * @returns {Value}
    */
    calculate(tx) {
        _assertClass(tx, Transaction);
        const ptr0 = tx.ptr;
        tx.ptr = 0;
        const ret = wasm.fee_calculate(this.ptr, ptr0);
        return Value.__wrap(ret);
    }
}
module.exports.Fee = Fee;
/**
* All possible messages recordable in the Block content
*/
class Fragment {

    static __wrap(ptr) {
        const obj = Object.create(Fragment.prototype);
        obj.ptr = ptr;

        return obj;
    }

    free() {
        const ptr = this.ptr;
        this.ptr = 0;

        wasm.__wbg_fragment_free(ptr);
    }
    /**
    * @param {Transaction} tx
    * @returns {Fragment}
    */
    static from_transaction(tx) {
        _assertClass(tx, Transaction);
        const ptr0 = tx.ptr;
        tx.ptr = 0;
        const ret = wasm.fragment_from_transaction(ptr0);
        return Fragment.__wrap(ret);
    }
    /**
    * Get a Transaction if the Fragment represents one
    * @returns {Transaction}
    */
    get_transaction() {
        const ptr = this.ptr;
        this.ptr = 0;
        const ret = wasm.fragment_get_transaction(ptr);
        return Transaction.__wrap(ret);
    }
    /**
    * @returns {Uint8Array}
    */
    as_bytes() {
        const retptr = 8;
        const ret = wasm.fragment_as_bytes(retptr, this.ptr);
        const memi32 = getInt32Memory();
        const v0 = getArrayU8FromWasm(memi32[retptr / 4 + 0], memi32[retptr / 4 + 1]).slice();
        wasm.__wbindgen_free(memi32[retptr / 4 + 0], memi32[retptr / 4 + 1] * 1);
        return v0;
    }
    /**
    * @param {any} bytes
    * @returns {Fragment}
    */
    static from_bytes(bytes) {
        const ret = wasm.fragment_from_bytes(addHeapObject(bytes));
        return Fragment.__wrap(ret);
    }
    /**
    * @returns {boolean}
    */
    is_initial() {
        const ret = wasm.fragment_is_initial(this.ptr);
        return ret !== 0;
    }
    /**
    * @returns {boolean}
    */
    is_transaction() {
        const ret = wasm.fragment_is_transaction(this.ptr);
        return ret !== 0;
    }
    /**
    * @returns {boolean}
    */
    is_owner_stake_delegation() {
        const ret = wasm.fragment_is_owner_stake_delegation(this.ptr);
        return ret !== 0;
    }
    /**
    * @returns {boolean}
    */
    is_stake_delegation() {
        const ret = wasm.fragment_is_stake_delegation(this.ptr);
        return ret !== 0;
    }
    /**
    * @returns {boolean}
    */
    is_pool_registration() {
        const ret = wasm.fragment_is_pool_registration(this.ptr);
        return ret !== 0;
    }
    /**
    * @returns {boolean}
    */
    is_pool_retirement() {
        const ret = wasm.fragment_is_pool_retirement(this.ptr);
        return ret !== 0;
    }
    /**
    * @returns {boolean}
    */
    is_pool_update() {
        const ret = wasm.fragment_is_pool_update(this.ptr);
        return ret !== 0;
    }
    /**
    * @returns {boolean}
    */
    is_old_utxo_declaration() {
        const ret = wasm.fragment_is_old_utxo_declaration(this.ptr);
        return ret !== 0;
    }
    /**
    * @returns {boolean}
    */
    is_update_proposal() {
        const ret = wasm.fragment_is_update_proposal(this.ptr);
        return ret !== 0;
    }
    /**
    * @returns {boolean}
    */
    is_update_vote() {
        const ret = wasm.fragment_is_update_vote(this.ptr);
        return ret !== 0;
    }
    /**
    * @returns {FragmentId}
    */
    id() {
        const ret = wasm.fragment_id(this.ptr);
        return FragmentId.__wrap(ret);
    }
}
module.exports.Fragment = Fragment;
/**
*/
class FragmentId {

    static __wrap(ptr) {
        const obj = Object.create(FragmentId.prototype);
        obj.ptr = ptr;

        return obj;
    }

    free() {
        const ptr = this.ptr;
        this.ptr = 0;

        wasm.__wbg_fragmentid_free(ptr);
    }
    /**
    * @param {Uint8Array} bytes
    * @returns {FragmentId}
    */
    static from_bytes(bytes) {
        const ret = wasm.fragmentid_from_bytes(passArray8ToWasm(bytes), WASM_VECTOR_LEN);
        return FragmentId.__wrap(ret);
    }
    /**
    * @returns {Uint8Array}
    */
    as_bytes() {
        const retptr = 8;
        const ret = wasm.fragmentid_as_bytes(retptr, this.ptr);
        const memi32 = getInt32Memory();
        const v0 = getArrayU8FromWasm(memi32[retptr / 4 + 0], memi32[retptr / 4 + 1]).slice();
        wasm.__wbindgen_free(memi32[retptr / 4 + 0], memi32[retptr / 4 + 1] * 1);
        return v0;
    }
}
module.exports.FragmentId = FragmentId;
/**
*/
class Fragments {

    static __wrap(ptr) {
        const obj = Object.create(Fragments.prototype);
        obj.ptr = ptr;

        return obj;
    }

    free() {
        const ptr = this.ptr;
        this.ptr = 0;

        wasm.__wbg_fragments_free(ptr);
    }
    /**
    * @returns {Fragments}
    */
    static new() {
        const ret = wasm.fragments_new();
        return Fragments.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    size() {
        const ret = wasm.fragments_size(this.ptr);
        return ret >>> 0;
    }
    /**
    * @param {number} index
    * @returns {Fragment}
    */
    get(index) {
        const ret = wasm.fragments_get(this.ptr, index);
        return Fragment.__wrap(ret);
    }
    /**
    * @param {Fragment} item
    */
    add(item) {
        _assertClass(item, Fragment);
        const ptr0 = item.ptr;
        item.ptr = 0;
        wasm.fragments_add(this.ptr, ptr0);
    }
}
module.exports.Fragments = Fragments;
/**
* Type for representing a generic Hash
*/
class Hash {

    static __wrap(ptr) {
        const obj = Object.create(Hash.prototype);
        obj.ptr = ptr;

        return obj;
    }

    free() {
        const ptr = this.ptr;
        this.ptr = 0;

        wasm.__wbg_hash_free(ptr);
    }
    /**
    * @param {Uint8Array} bytes
    * @returns {Hash}
    */
    static from_bytes(bytes) {
        const ret = wasm.hash_from_bytes(passArray8ToWasm(bytes), WASM_VECTOR_LEN);
        return Hash.__wrap(ret);
    }
    /**
    * @param {string} hex_string
    * @returns {Hash}
    */
    static from_hex(hex_string) {
        const ret = wasm.hash_from_hex(passStringToWasm(hex_string), WASM_VECTOR_LEN);
        return Hash.__wrap(ret);
    }
    /**
    * @returns {Uint8Array}
    */
    as_bytes() {
        const retptr = 8;
        const ret = wasm.hash_as_bytes(retptr, this.ptr);
        const memi32 = getInt32Memory();
        const v0 = getArrayU8FromWasm(memi32[retptr / 4 + 0], memi32[retptr / 4 + 1]).slice();
        wasm.__wbindgen_free(memi32[retptr / 4 + 0], memi32[retptr / 4 + 1] * 1);
        return v0;
    }
}
module.exports.Hash = Hash;
/**
*/
class IndexSignatures {

    static __wrap(ptr) {
        const obj = Object.create(IndexSignatures.prototype);
        obj.ptr = ptr;

        return obj;
    }

    free() {
        const ptr = this.ptr;
        this.ptr = 0;

        wasm.__wbg_indexsignatures_free(ptr);
    }
    /**
    * @returns {IndexSignatures}
    */
    static new() {
        const ret = wasm.indexsignatures_new();
        return IndexSignatures.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    size() {
        const ret = wasm.indexsignatures_size(this.ptr);
        return ret >>> 0;
    }
    /**
    * @param {number} index
    * @returns {IndexedSignature}
    */
    get(index) {
        const ret = wasm.indexsignatures_get(this.ptr, index);
        return IndexedSignature.__wrap(ret);
    }
    /**
    * @param {IndexedSignature} item
    */
    add(item) {
        _assertClass(item, IndexedSignature);
        const ptr0 = item.ptr;
        item.ptr = 0;
        wasm.indexsignatures_add(this.ptr, ptr0);
    }
}
module.exports.IndexSignatures = IndexSignatures;
/**
*/
class IndexedSignature {

    static __wrap(ptr) {
        const obj = Object.create(IndexedSignature.prototype);
        obj.ptr = ptr;

        return obj;
    }

    free() {
        const ptr = this.ptr;
        this.ptr = 0;

        wasm.__wbg_indexedsignature_free(ptr);
    }
    /**
    * @param {number} index
    * @param {AccountBindingSignature} signature
    * @returns {IndexedSignature}
    */
    static new(index, signature) {
        _assertClass(signature, AccountBindingSignature);
        const ptr0 = signature.ptr;
        signature.ptr = 0;
        const ret = wasm.indexedsignature_new(index, ptr0);
        return IndexedSignature.__wrap(ret);
    }
}
module.exports.IndexedSignature = IndexedSignature;
/**
*/
class Input {

    static __wrap(ptr) {
        const obj = Object.create(Input.prototype);
        obj.ptr = ptr;

        return obj;
    }

    free() {
        const ptr = this.ptr;
        this.ptr = 0;

        wasm.__wbg_input_free(ptr);
    }
    /**
    * @param {UtxoPointer} utxo_pointer
    * @returns {Input}
    */
    static from_utxo(utxo_pointer) {
        _assertClass(utxo_pointer, UtxoPointer);
        const ret = wasm.input_from_utxo(utxo_pointer.ptr);
        return Input.__wrap(ret);
    }
    /**
    * @param {Account} account
    * @param {Value} v
    * @returns {Input}
    */
    static from_account(account, v) {
        _assertClass(account, Account);
        _assertClass(v, Value);
        const ptr0 = v.ptr;
        v.ptr = 0;
        const ret = wasm.input_from_account(account.ptr, ptr0);
        return Input.__wrap(ret);
    }
    /**
    * Get the kind of Input, this can be either \"Account\" or \"Utxo\
    * @returns {string}
    */
    get_type() {
        const retptr = 8;
        const ret = wasm.input_get_type(retptr, this.ptr);
        const memi32 = getInt32Memory();
        const v0 = getStringFromWasm(memi32[retptr / 4 + 0], memi32[retptr / 4 + 1]).slice();
        wasm.__wbindgen_free(memi32[retptr / 4 + 0], memi32[retptr / 4 + 1] * 1);
        return v0;
    }
    /**
    * @returns {boolean}
    */
    is_account() {
        const ret = wasm.input_is_account(this.ptr);
        return ret !== 0;
    }
    /**
    * @returns {boolean}
    */
    is_utxo() {
        const ret = wasm.input_is_utxo(this.ptr);
        return ret !== 0;
    }
    /**
    * @returns {Value}
    */
    value() {
        const ret = wasm.input_value(this.ptr);
        return Value.__wrap(ret);
    }
    /**
    * Get the inner UtxoPointer if the Input type is Utxo
    * @returns {UtxoPointer}
    */
    get_utxo_pointer() {
        const ret = wasm.input_get_utxo_pointer(this.ptr);
        return UtxoPointer.__wrap(ret);
    }
    /**
    * Get the source Account if the Input type is Account
    * @returns {AccountIdentifier}
    */
    get_account_identifier() {
        const ret = wasm.input_get_account_identifier(this.ptr);
        return AccountIdentifier.__wrap(ret);
    }
}
module.exports.Input = Input;
/**
*/
class InputOutput {

    static __wrap(ptr) {
        const obj = Object.create(InputOutput.prototype);
        obj.ptr = ptr;

        return obj;
    }

    free() {
        const ptr = this.ptr;
        this.ptr = 0;

        wasm.__wbg_inputoutput_free(ptr);
    }
    /**
    * @returns {Inputs}
    */
    inputs() {
        const ret = wasm.inputoutput_inputs(this.ptr);
        return Inputs.__wrap(ret);
    }
    /**
    * @returns {Outputs}
    */
    outputs() {
        const ret = wasm.inputoutput_outputs(this.ptr);
        return Outputs.__wrap(ret);
    }
}
module.exports.InputOutput = InputOutput;
/**
*/
class InputOutputBuilder {

    static __wrap(ptr) {
        const obj = Object.create(InputOutputBuilder.prototype);
        obj.ptr = ptr;

        return obj;
    }

    free() {
        const ptr = this.ptr;
        this.ptr = 0;

        wasm.__wbg_inputoutputbuilder_free(ptr);
    }
    /**
    * @returns {InputOutputBuilder}
    */
    static empty() {
        const ret = wasm.inputoutputbuilder_empty();
        return InputOutputBuilder.__wrap(ret);
    }
    /**
    * Add input to the IO Builder
    * @param {Input} input
    */
    add_input(input) {
        _assertClass(input, Input);
        wasm.inputoutputbuilder_add_input(this.ptr, input.ptr);
    }
    /**
    * Add output to the IO Builder
    * @param {Address} address
    * @param {Value} value
    */
    add_output(address, value) {
        _assertClass(address, Address);
        const ptr0 = address.ptr;
        address.ptr = 0;
        _assertClass(value, Value);
        const ptr1 = value.ptr;
        value.ptr = 0;
        wasm.inputoutputbuilder_add_output(this.ptr, ptr0, ptr1);
    }
    /**
    * Estimate fee with the currently added inputs, outputs and certificate based on the given algorithm
    * @param {Fee} fee
    * @param {Payload} payload
    * @returns {Value}
    */
    estimate_fee(fee, payload) {
        _assertClass(fee, Fee);
        _assertClass(payload, Payload);
        const ret = wasm.inputoutputbuilder_estimate_fee(this.ptr, fee.ptr, payload.ptr);
        return Value.__wrap(ret);
    }
    /**
    * @param {Payload} payload
    * @param {Fee} fee
    * @returns {Balance}
    */
    get_balance(payload, fee) {
        _assertClass(payload, Payload);
        _assertClass(fee, Fee);
        const ret = wasm.inputoutputbuilder_get_balance(this.ptr, payload.ptr, fee.ptr);
        return Balance.__wrap(ret);
    }
    /**
    * @returns {Balance}
    */
    get_balance_without_fee() {
        const ret = wasm.inputoutputbuilder_get_balance_without_fee(this.ptr);
        return Balance.__wrap(ret);
    }
    /**
    * @returns {InputOutput}
    */
    build() {
        const ptr = this.ptr;
        this.ptr = 0;
        const ret = wasm.inputoutputbuilder_build(ptr);
        return InputOutput.__wrap(ret);
    }
    /**
    * Seal the transaction by passing fee rule
    * @param {Payload} payload
    * @param {Fee} fee_algorithm
    * @returns {InputOutput}
    */
    seal(payload, fee_algorithm) {
        const ptr = this.ptr;
        this.ptr = 0;
        _assertClass(payload, Payload);
        _assertClass(fee_algorithm, Fee);
        const ptr0 = fee_algorithm.ptr;
        fee_algorithm.ptr = 0;
        const ret = wasm.inputoutputbuilder_seal(ptr, payload.ptr, ptr0);
        return InputOutput.__wrap(ret);
    }
    /**
    * Seal the transaction by passing fee rule and the output policy
    * @param {Payload} payload
    * @param {Fee} fee_algorithm
    * @param {OutputPolicy} policy
    * @returns {InputOutput}
    */
    seal_with_output_policy(payload, fee_algorithm, policy) {
        const ptr = this.ptr;
        this.ptr = 0;
        _assertClass(payload, Payload);
        _assertClass(fee_algorithm, Fee);
        const ptr0 = fee_algorithm.ptr;
        fee_algorithm.ptr = 0;
        _assertClass(policy, OutputPolicy);
        const ptr1 = policy.ptr;
        policy.ptr = 0;
        const ret = wasm.inputoutputbuilder_seal_with_output_policy(ptr, payload.ptr, ptr0, ptr1);
        return InputOutput.__wrap(ret);
    }
}
module.exports.InputOutputBuilder = InputOutputBuilder;
/**
*/
class Inputs {

    static __wrap(ptr) {
        const obj = Object.create(Inputs.prototype);
        obj.ptr = ptr;

        return obj;
    }

    free() {
        const ptr = this.ptr;
        this.ptr = 0;

        wasm.__wbg_inputs_free(ptr);
    }
    /**
    * @returns {Inputs}
    */
    static new() {
        const ret = wasm.inputs_new();
        return Inputs.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    size() {
        const ret = wasm.inputs_size(this.ptr);
        return ret >>> 0;
    }
    /**
    * @param {number} index
    * @returns {Input}
    */
    get(index) {
        const ret = wasm.inputs_get(this.ptr, index);
        return Input.__wrap(ret);
    }
    /**
    * @param {Input} item
    */
    add(item) {
        _assertClass(item, Input);
        const ptr0 = item.ptr;
        item.ptr = 0;
        wasm.inputs_add(this.ptr, ptr0);
    }
}
module.exports.Inputs = Inputs;
/**
*/
class KesPublicKey {

    static __wrap(ptr) {
        const obj = Object.create(KesPublicKey.prototype);
        obj.ptr = ptr;

        return obj;
    }

    free() {
        const ptr = this.ptr;
        this.ptr = 0;

        wasm.__wbg_kespublickey_free(ptr);
    }
    /**
    * @param {string} bech32_str
    * @returns {KesPublicKey}
    */
    static from_bech32(bech32_str) {
        const ret = wasm.kespublickey_from_bech32(passStringToWasm(bech32_str), WASM_VECTOR_LEN);
        return KesPublicKey.__wrap(ret);
    }
}
module.exports.KesPublicKey = KesPublicKey;
/**
* Type for representing a Transaction Output, composed of an Address and a Value
*/
class Output {

    static __wrap(ptr) {
        const obj = Object.create(Output.prototype);
        obj.ptr = ptr;

        return obj;
    }

    free() {
        const ptr = this.ptr;
        this.ptr = 0;

        wasm.__wbg_output_free(ptr);
    }
    /**
    * @returns {Address}
    */
    address() {
        const ret = wasm.output_address(this.ptr);
        return Address.__wrap(ret);
    }
    /**
    * @returns {Value}
    */
    value() {
        const ret = wasm.output_value(this.ptr);
        return Value.__wrap(ret);
    }
}
module.exports.Output = Output;
/**
* Helper to add change addresses when finalizing a transaction, there are currently two options
* * forget: use all the excess money as fee
* * one: send all the excess money to the given address
*/
class OutputPolicy {

    static __wrap(ptr) {
        const obj = Object.create(OutputPolicy.prototype);
        obj.ptr = ptr;

        return obj;
    }

    free() {
        const ptr = this.ptr;
        this.ptr = 0;

        wasm.__wbg_outputpolicy_free(ptr);
    }
    /**
    * don\'t do anything with the excess money in transaction
    * @returns {OutputPolicy}
    */
    static forget() {
        const ret = wasm.outputpolicy_forget();
        return OutputPolicy.__wrap(ret);
    }
    /**
    * use the given address as the only change address
    * @param {Address} address
    * @returns {OutputPolicy}
    */
    static one(address) {
        _assertClass(address, Address);
        const ptr0 = address.ptr;
        address.ptr = 0;
        const ret = wasm.outputpolicy_one(ptr0);
        return OutputPolicy.__wrap(ret);
    }
}
module.exports.OutputPolicy = OutputPolicy;
/**
*/
class Outputs {

    static __wrap(ptr) {
        const obj = Object.create(Outputs.prototype);
        obj.ptr = ptr;

        return obj;
    }

    free() {
        const ptr = this.ptr;
        this.ptr = 0;

        wasm.__wbg_outputs_free(ptr);
    }
    /**
    * @returns {Outputs}
    */
    static new() {
        const ret = wasm.outputs_new();
        return Outputs.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    size() {
        const ret = wasm.outputs_size(this.ptr);
        return ret >>> 0;
    }
    /**
    * @param {number} index
    * @returns {Output}
    */
    get(index) {
        const ret = wasm.outputs_get(this.ptr, index);
        return Output.__wrap(ret);
    }
    /**
    * @param {Output} item
    */
    add(item) {
        _assertClass(item, Output);
        const ptr0 = item.ptr;
        item.ptr = 0;
        wasm.outputs_add(this.ptr, ptr0);
    }
}
module.exports.Outputs = Outputs;
/**
*/
class Payload {

    static __wrap(ptr) {
        const obj = Object.create(Payload.prototype);
        obj.ptr = ptr;

        return obj;
    }

    free() {
        const ptr = this.ptr;
        this.ptr = 0;

        wasm.__wbg_payload_free(ptr);
    }
    /**
    * @returns {Payload}
    */
    static no_payload() {
        const ret = wasm.payload_no_payload();
        return Payload.__wrap(ret);
    }
    /**
    * @param {Certificate} certificate
    * @returns {Payload}
    */
    static certificate(certificate) {
        _assertClass(certificate, Certificate);
        const ret = wasm.payload_certificate(certificate.ptr);
        return Payload.__wrap(ret);
    }
}
module.exports.Payload = Payload;
/**
*/
class PayloadAuthData {

    static __wrap(ptr) {
        const obj = Object.create(PayloadAuthData.prototype);
        obj.ptr = ptr;

        return obj;
    }

    free() {
        const ptr = this.ptr;
        this.ptr = 0;

        wasm.__wbg_payloadauthdata_free(ptr);
    }
    /**
    * @returns {PayloadAuthData}
    */
    static for_no_payload() {
        const ret = wasm.payloadauthdata_for_no_payload();
        return PayloadAuthData.__wrap(ret);
    }
    /**
    * @returns {PayloadAuthData}
    */
    static for_owner_stake_delegation() {
        const ret = wasm.payloadauthdata_for_owner_stake_delegation();
        return PayloadAuthData.__wrap(ret);
    }
    /**
    * @param {StakeDelegationAuthData} auth_data
    * @returns {PayloadAuthData}
    */
    static for_stake_delegation(auth_data) {
        _assertClass(auth_data, StakeDelegationAuthData);
        const ptr0 = auth_data.ptr;
        auth_data.ptr = 0;
        const ret = wasm.payloadauthdata_for_stake_delegation(ptr0);
        return PayloadAuthData.__wrap(ret);
    }
    /**
    * @param {PoolRegistrationAuthData} auth_data
    * @returns {PayloadAuthData}
    */
    static for_pool_registration(auth_data) {
        _assertClass(auth_data, PoolRegistrationAuthData);
        const ptr0 = auth_data.ptr;
        auth_data.ptr = 0;
        const ret = wasm.payloadauthdata_for_pool_registration(ptr0);
        return PayloadAuthData.__wrap(ret);
    }
    /**
    * @param {PoolRetirementAuthData} auth_data
    * @returns {PayloadAuthData}
    */
    static for_pool_retirement(auth_data) {
        _assertClass(auth_data, PoolRetirementAuthData);
        const ptr0 = auth_data.ptr;
        auth_data.ptr = 0;
        const ret = wasm.payloadauthdata_for_pool_retirement(ptr0);
        return PayloadAuthData.__wrap(ret);
    }
    /**
    * @param {PoolUpdateAuthData} auth_data
    * @returns {PayloadAuthData}
    */
    static for_pool_update(auth_data) {
        _assertClass(auth_data, PoolUpdateAuthData);
        const ptr0 = auth_data.ptr;
        auth_data.ptr = 0;
        const ret = wasm.payloadauthdata_for_pool_update(ptr0);
        return PayloadAuthData.__wrap(ret);
    }
}
module.exports.PayloadAuthData = PayloadAuthData;
/**
*/
class PoolDelegationRatio {

    static __wrap(ptr) {
        const obj = Object.create(PoolDelegationRatio.prototype);
        obj.ptr = ptr;

        return obj;
    }

    free() {
        const ptr = this.ptr;
        this.ptr = 0;

        wasm.__wbg_pooldelegationratio_free(ptr);
    }
    /**
    * @param {PoolId} pool
    * @param {number} part
    * @returns {PoolDelegationRatio}
    */
    static new(pool, part) {
        _assertClass(pool, PoolId);
        const ptr0 = pool.ptr;
        pool.ptr = 0;
        const ret = wasm.pooldelegationratio_new(ptr0, part);
        return PoolDelegationRatio.__wrap(ret);
    }
}
module.exports.PoolDelegationRatio = PoolDelegationRatio;
/**
*/
class PoolDelegationRatios {

    static __wrap(ptr) {
        const obj = Object.create(PoolDelegationRatios.prototype);
        obj.ptr = ptr;

        return obj;
    }

    free() {
        const ptr = this.ptr;
        this.ptr = 0;

        wasm.__wbg_pooldelegationratios_free(ptr);
    }
    /**
    * @returns {PoolDelegationRatios}
    */
    static new() {
        const ret = wasm.pooldelegationratios_new();
        return PoolDelegationRatios.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    size() {
        const ret = wasm.pooldelegationratios_size(this.ptr);
        return ret >>> 0;
    }
    /**
    * @param {number} index
    * @returns {PoolDelegationRatio}
    */
    get(index) {
        const ret = wasm.pooldelegationratios_get(this.ptr, index);
        return PoolDelegationRatio.__wrap(ret);
    }
    /**
    * @param {PoolDelegationRatio} item
    */
    add(item) {
        _assertClass(item, PoolDelegationRatio);
        const ptr0 = item.ptr;
        item.ptr = 0;
        wasm.pooldelegationratios_add(this.ptr, ptr0);
    }
}
module.exports.PoolDelegationRatios = PoolDelegationRatios;
/**
*/
class PoolId {

    static __wrap(ptr) {
        const obj = Object.create(PoolId.prototype);
        obj.ptr = ptr;

        return obj;
    }

    free() {
        const ptr = this.ptr;
        this.ptr = 0;

        wasm.__wbg_poolid_free(ptr);
    }
    /**
    * @param {string} hex_string
    * @returns {PoolId}
    */
    static from_hex(hex_string) {
        const ret = wasm.poolid_from_hex(passStringToWasm(hex_string), WASM_VECTOR_LEN);
        return PoolId.__wrap(ret);
    }
    /**
    * @returns {string}
    */
    to_string() {
        const retptr = 8;
        const ret = wasm.poolid_to_string(retptr, this.ptr);
        const memi32 = getInt32Memory();
        const v0 = getStringFromWasm(memi32[retptr / 4 + 0], memi32[retptr / 4 + 1]).slice();
        wasm.__wbindgen_free(memi32[retptr / 4 + 0], memi32[retptr / 4 + 1] * 1);
        return v0;
    }
}
module.exports.PoolId = PoolId;
/**
*/
class PoolRegistration {

    static __wrap(ptr) {
        const obj = Object.create(PoolRegistration.prototype);
        obj.ptr = ptr;

        return obj;
    }

    free() {
        const ptr = this.ptr;
        this.ptr = 0;

        wasm.__wbg_poolregistration_free(ptr);
    }
    /**
    * @param {U128} serial
    * @param {PublicKeys} owners
    * @param {PublicKeys} operators
    * @param {number} management_threshold
    * @param {TimeOffsetSeconds} start_validity
    * @param {KesPublicKey} kes_public_key
    * @param {VrfPublicKey} vrf_public_key
    * @returns {PoolRegistration}
    */
    constructor(serial, owners, operators, management_threshold, start_validity, kes_public_key, vrf_public_key) {
        _assertClass(serial, U128);
        const ptr0 = serial.ptr;
        serial.ptr = 0;
        _assertClass(owners, PublicKeys);
        const ptr1 = owners.ptr;
        owners.ptr = 0;
        _assertClass(operators, PublicKeys);
        const ptr2 = operators.ptr;
        operators.ptr = 0;
        _assertClass(start_validity, TimeOffsetSeconds);
        const ptr3 = start_validity.ptr;
        start_validity.ptr = 0;
        _assertClass(kes_public_key, KesPublicKey);
        const ptr4 = kes_public_key.ptr;
        kes_public_key.ptr = 0;
        _assertClass(vrf_public_key, VrfPublicKey);
        const ptr5 = vrf_public_key.ptr;
        vrf_public_key.ptr = 0;
        const ret = wasm.poolregistration_new(ptr0, ptr1, ptr2, management_threshold, ptr3, ptr4, ptr5);
        return PoolRegistration.__wrap(ret);
    }
    /**
    * @returns {PoolId}
    */
    id() {
        const ret = wasm.poolregistration_id(this.ptr);
        return PoolId.__wrap(ret);
    }
}
module.exports.PoolRegistration = PoolRegistration;
/**
*/
class PoolRegistrationAuthData {

    static __wrap(ptr) {
        const obj = Object.create(PoolRegistrationAuthData.prototype);
        obj.ptr = ptr;

        return obj;
    }

    free() {
        const ptr = this.ptr;
        this.ptr = 0;

        wasm.__wbg_poolregistrationauthdata_free(ptr);
    }
    /**
    * @param {IndexSignatures} signatures
    * @returns {PoolRegistrationAuthData}
    */
    static new(signatures) {
        _assertClass(signatures, IndexSignatures);
        const ptr0 = signatures.ptr;
        signatures.ptr = 0;
        const ret = wasm.poolregistrationauthdata_new(ptr0);
        return PoolRegistrationAuthData.__wrap(ret);
    }
}
module.exports.PoolRegistrationAuthData = PoolRegistrationAuthData;
/**
*/
class PoolRetirementAuthData {

    static __wrap(ptr) {
        const obj = Object.create(PoolRetirementAuthData.prototype);
        obj.ptr = ptr;

        return obj;
    }

    free() {
        const ptr = this.ptr;
        this.ptr = 0;

        wasm.__wbg_poolretirementauthdata_free(ptr);
    }
    /**
    * @param {IndexSignatures} signatures
    * @returns {PoolRetirementAuthData}
    */
    static new(signatures) {
        _assertClass(signatures, IndexSignatures);
        const ptr0 = signatures.ptr;
        signatures.ptr = 0;
        const ret = wasm.poolretirementauthdata_new(ptr0);
        return PoolRetirementAuthData.__wrap(ret);
    }
}
module.exports.PoolRetirementAuthData = PoolRetirementAuthData;
/**
*/
class PoolUpdateAuthData {

    static __wrap(ptr) {
        const obj = Object.create(PoolUpdateAuthData.prototype);
        obj.ptr = ptr;

        return obj;
    }

    free() {
        const ptr = this.ptr;
        this.ptr = 0;

        wasm.__wbg_poolupdateauthdata_free(ptr);
    }
    /**
    * @param {IndexSignatures} signatures
    * @returns {PoolUpdateAuthData}
    */
    static new(signatures) {
        _assertClass(signatures, IndexSignatures);
        const ptr0 = signatures.ptr;
        signatures.ptr = 0;
        const ret = wasm.poolupdateauthdata_new(ptr0);
        return PoolUpdateAuthData.__wrap(ret);
    }
}
module.exports.PoolUpdateAuthData = PoolUpdateAuthData;
/**
* ED25519 signing key, either normal or extended
*/
class PrivateKey {

    static __wrap(ptr) {
        const obj = Object.create(PrivateKey.prototype);
        obj.ptr = ptr;

        return obj;
    }

    free() {
        const ptr = this.ptr;
        this.ptr = 0;

        wasm.__wbg_privatekey_free(ptr);
    }
    /**
    * Get private key from its bech32 representation
    * ```javascript
    * PrivateKey.from_bech32(&#39;ed25519_sk1ahfetf02qwwg4dkq7mgp4a25lx5vh9920cr5wnxmpzz9906qvm8qwvlts0&#39;);
    * ```
    * For an extended 25519 key
    * ```javascript
    * PrivateKey.from_bech32(&#39;ed25519e_sk1gqwl4szuwwh6d0yk3nsqcc6xxc3fpvjlevgwvt60df59v8zd8f8prazt8ln3lmz096ux3xvhhvm3ca9wj2yctdh3pnw0szrma07rt5gl748fp&#39;);
    * ```
    * @param {string} bech32_str
    * @returns {PrivateKey}
    */
    static from_bech32(bech32_str) {
        const ret = wasm.privatekey_from_bech32(passStringToWasm(bech32_str), WASM_VECTOR_LEN);
        return PrivateKey.__wrap(ret);
    }
    /**
    * @returns {PublicKey}
    */
    to_public() {
        const ret = wasm.privatekey_to_public(this.ptr);
        return PublicKey.__wrap(ret);
    }
    /**
    * @returns {PrivateKey}
    */
    static generate_ed25519() {
        const ret = wasm.privatekey_generate_ed25519();
        return PrivateKey.__wrap(ret);
    }
    /**
    * @returns {PrivateKey}
    */
    static generate_ed25519extended() {
        const ret = wasm.privatekey_generate_ed25519extended();
        return PrivateKey.__wrap(ret);
    }
    /**
    * @returns {string}
    */
    to_bech32() {
        const retptr = 8;
        const ret = wasm.privatekey_to_bech32(retptr, this.ptr);
        const memi32 = getInt32Memory();
        const v0 = getStringFromWasm(memi32[retptr / 4 + 0], memi32[retptr / 4 + 1]).slice();
        wasm.__wbindgen_free(memi32[retptr / 4 + 0], memi32[retptr / 4 + 1] * 1);
        return v0;
    }
    /**
    * @param {Uint8Array} bytes
    * @returns {PrivateKey}
    */
    static from_extended_bytes(bytes) {
        const ret = wasm.privatekey_from_extended_bytes(passArray8ToWasm(bytes), WASM_VECTOR_LEN);
        return PrivateKey.__wrap(ret);
    }
    /**
    * @param {Uint8Array} bytes
    * @returns {PrivateKey}
    */
    static from_normal_bytes(bytes) {
        const ret = wasm.privatekey_from_normal_bytes(passArray8ToWasm(bytes), WASM_VECTOR_LEN);
        return PrivateKey.__wrap(ret);
    }
}
module.exports.PrivateKey = PrivateKey;
/**
* ED25519 key used as public key
*/
class PublicKey {

    static __wrap(ptr) {
        const obj = Object.create(PublicKey.prototype);
        obj.ptr = ptr;

        return obj;
    }

    free() {
        const ptr = this.ptr;
        this.ptr = 0;

        wasm.__wbg_publickey_free(ptr);
    }
    /**
    * Get private key from its bech32 representation
    * Example:
    * ```javascript
    * const pkey = PublicKey.from_bech32(&#39;ed25519_pk1dgaagyh470y66p899txcl3r0jaeaxu6yd7z2dxyk55qcycdml8gszkxze2&#39;);
    * ```
    * @param {string} bech32_str
    * @returns {PublicKey}
    */
    static from_bech32(bech32_str) {
        const ret = wasm.publickey_from_bech32(passStringToWasm(bech32_str), WASM_VECTOR_LEN);
        return PublicKey.__wrap(ret);
    }
    /**
    * @returns {Uint8Array}
    */
    as_bytes() {
        const retptr = 8;
        const ret = wasm.publickey_as_bytes(retptr, this.ptr);
        const memi32 = getInt32Memory();
        const v0 = getArrayU8FromWasm(memi32[retptr / 4 + 0], memi32[retptr / 4 + 1]).slice();
        wasm.__wbindgen_free(memi32[retptr / 4 + 0], memi32[retptr / 4 + 1] * 1);
        return v0;
    }
    /**
    * @param {Uint8Array} bytes
    * @returns {PublicKey}
    */
    static from_bytes(bytes) {
        const ret = wasm.publickey_from_bytes(passArray8ToWasm(bytes), WASM_VECTOR_LEN);
        return PublicKey.__wrap(ret);
    }
}
module.exports.PublicKey = PublicKey;
/**
*/
class PublicKeys {

    static __wrap(ptr) {
        const obj = Object.create(PublicKeys.prototype);
        obj.ptr = ptr;

        return obj;
    }

    free() {
        const ptr = this.ptr;
        this.ptr = 0;

        wasm.__wbg_publickeys_free(ptr);
    }
    /**
    * @returns {PublicKeys}
    */
    constructor() {
        const ret = wasm.publickeys_new();
        return PublicKeys.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    size() {
        const ret = wasm.publickeys_size(this.ptr);
        return ret >>> 0;
    }
    /**
    * @param {number} index
    * @returns {PublicKey}
    */
    get(index) {
        const ret = wasm.publickeys_get(this.ptr, index);
        return PublicKey.__wrap(ret);
    }
    /**
    * @param {PublicKey} key
    */
    add(key) {
        _assertClass(key, PublicKey);
        const ptr0 = key.ptr;
        key.ptr = 0;
        wasm.publickeys_add(this.ptr, ptr0);
    }
}
module.exports.PublicKeys = PublicKeys;
/**
*/
class SpendingCounter {

    static __wrap(ptr) {
        const obj = Object.create(SpendingCounter.prototype);
        obj.ptr = ptr;

        return obj;
    }

    free() {
        const ptr = this.ptr;
        this.ptr = 0;

        wasm.__wbg_spendingcounter_free(ptr);
    }
    /**
    * @returns {SpendingCounter}
    */
    static zero() {
        const ret = wasm.spendingcounter_zero();
        return SpendingCounter.__wrap(ret);
    }
    /**
    * @param {number} counter
    * @returns {SpendingCounter}
    */
    static from_u32(counter) {
        const ret = wasm.spendingcounter_from_u32(counter);
        return SpendingCounter.__wrap(ret);
    }
}
module.exports.SpendingCounter = SpendingCounter;
/**
*/
class StakeDelegation {

    static __wrap(ptr) {
        const obj = Object.create(StakeDelegation.prototype);
        obj.ptr = ptr;

        return obj;
    }

    free() {
        const ptr = this.ptr;
        this.ptr = 0;

        wasm.__wbg_stakedelegation_free(ptr);
    }
    /**
    * Create a stake delegation object from account (stake key) to pool_id
    * @param {DelegationType} delegation_type
    * @param {PublicKey} account
    * @returns {StakeDelegation}
    */
    static new(delegation_type, account) {
        _assertClass(delegation_type, DelegationType);
        const ptr0 = delegation_type.ptr;
        delegation_type.ptr = 0;
        _assertClass(account, PublicKey);
        const ptr1 = account.ptr;
        account.ptr = 0;
        const ret = wasm.stakedelegation_new(ptr0, ptr1);
        return StakeDelegation.__wrap(ret);
    }
}
module.exports.StakeDelegation = StakeDelegation;
/**
*/
class StakeDelegationAuthData {

    static __wrap(ptr) {
        const obj = Object.create(StakeDelegationAuthData.prototype);
        obj.ptr = ptr;

        return obj;
    }

    free() {
        const ptr = this.ptr;
        this.ptr = 0;

        wasm.__wbg_stakedelegationauthdata_free(ptr);
    }
    /**
    * @param {AccountBindingSignature} signature
    * @returns {StakeDelegationAuthData}
    */
    static new(signature) {
        _assertClass(signature, AccountBindingSignature);
        const ptr0 = signature.ptr;
        signature.ptr = 0;
        const ret = wasm.stakedelegationauthdata_new(ptr0);
        return StakeDelegationAuthData.__wrap(ret);
    }
}
module.exports.StakeDelegationAuthData = StakeDelegationAuthData;
/**
*/
class TimeOffsetSeconds {

    static __wrap(ptr) {
        const obj = Object.create(TimeOffsetSeconds.prototype);
        obj.ptr = ptr;

        return obj;
    }

    free() {
        const ptr = this.ptr;
        this.ptr = 0;

        wasm.__wbg_timeoffsetseconds_free(ptr);
    }
    /**
    * Parse the given string into a 64 bits unsigned number
    * @param {string} number
    * @returns {TimeOffsetSeconds}
    */
    static from_string(number) {
        const ret = wasm.timeoffsetseconds_from_string(passStringToWasm(number), WASM_VECTOR_LEN);
        return TimeOffsetSeconds.__wrap(ret);
    }
}
module.exports.TimeOffsetSeconds = TimeOffsetSeconds;
/**
*/
class Transaction {

    static __wrap(ptr) {
        const obj = Object.create(Transaction.prototype);
        obj.ptr = ptr;

        return obj;
    }

    free() {
        const ptr = this.ptr;
        this.ptr = 0;

        wasm.__wbg_transaction_free(ptr);
    }
    /**
    * Get the transaction id, needed to compute its signature
    * @returns {TransactionSignDataHash}
    */
    id() {
        const ret = wasm.transaction_id(this.ptr);
        return TransactionSignDataHash.__wrap(ret);
    }
    /**
    * Get collection of the inputs in the transaction (this allocates new copies of all the values)
    * @returns {Inputs}
    */
    inputs() {
        const ret = wasm.transaction_inputs(this.ptr);
        return Inputs.__wrap(ret);
    }
    /**
    * Get collection of the outputs in the transaction (this allocates new copies of all the values)
    * @returns {Outputs}
    */
    outputs() {
        const ret = wasm.transaction_outputs(this.ptr);
        return Outputs.__wrap(ret);
    }
    /**
    * @returns {Transaction}
    */
    clone() {
        const ret = wasm.transaction_clone(this.ptr);
        return Transaction.__wrap(ret);
    }
    /**
    * @returns {Witnesses}
    */
    witnesses() {
        const ret = wasm.transaction_witnesses(this.ptr);
        return Witnesses.__wrap(ret);
    }
}
module.exports.Transaction = Transaction;
/**
*/
class TransactionBindingAuthData {

    static __wrap(ptr) {
        const obj = Object.create(TransactionBindingAuthData.prototype);
        obj.ptr = ptr;

        return obj;
    }

    free() {
        const ptr = this.ptr;
        this.ptr = 0;

        wasm.__wbg_transactionbindingauthdata_free(ptr);
    }
}
module.exports.TransactionBindingAuthData = TransactionBindingAuthData;
/**
* Builder pattern implementation for making a Transaction
*
* Example
*
* ```javascript
* ```
*/
class TransactionBuilder {

    static __wrap(ptr) {
        const obj = Object.create(TransactionBuilder.prototype);
        obj.ptr = ptr;

        return obj;
    }

    free() {
        const ptr = this.ptr;
        this.ptr = 0;

        wasm.__wbg_transactionbuilder_free(ptr);
    }
    /**
    * @returns {TransactionBuilder}
    */
    constructor() {
        const ret = wasm.transactionbuilder_new();
        return TransactionBuilder.__wrap(ret);
    }
    /**
    * @param {Certificate} cert
    * @returns {TransactionBuilderSetIOs}
    */
    payload(cert) {
        const ptr = this.ptr;
        this.ptr = 0;
        _assertClass(cert, Certificate);
        const ret = wasm.transactionbuilder_payload(ptr, cert.ptr);
        return TransactionBuilderSetIOs.__wrap(ret);
    }
    /**
    * @returns {TransactionBuilderSetIOs}
    */
    no_payload() {
        const ptr = this.ptr;
        this.ptr = 0;
        const ret = wasm.transactionbuilder_no_payload(ptr);
        return TransactionBuilderSetIOs.__wrap(ret);
    }
}
module.exports.TransactionBuilder = TransactionBuilder;
/**
*/
class TransactionBuilderSetAuthData {

    static __wrap(ptr) {
        const obj = Object.create(TransactionBuilderSetAuthData.prototype);
        obj.ptr = ptr;

        return obj;
    }

    free() {
        const ptr = this.ptr;
        this.ptr = 0;

        wasm.__wbg_transactionbuildersetauthdata_free(ptr);
    }
    /**
    * @returns {TransactionBindingAuthData}
    */
    get_auth_data() {
        const ret = wasm.transactionbuildersetauthdata_get_auth_data(this.ptr);
        return TransactionBindingAuthData.__wrap(ret);
    }
    /**
    * Set the authenticated data
    * @param {PayloadAuthData} auth
    * @returns {Transaction}
    */
    set_payload_auth(auth) {
        const ptr = this.ptr;
        this.ptr = 0;
        _assertClass(auth, PayloadAuthData);
        const ptr0 = auth.ptr;
        auth.ptr = 0;
        const ret = wasm.transactionbuildersetauthdata_set_payload_auth(ptr, ptr0);
        return Transaction.__wrap(ret);
    }
}
module.exports.TransactionBuilderSetAuthData = TransactionBuilderSetAuthData;
/**
*/
class TransactionBuilderSetIOs {

    static __wrap(ptr) {
        const obj = Object.create(TransactionBuilderSetIOs.prototype);
        obj.ptr = ptr;

        return obj;
    }

    free() {
        const ptr = this.ptr;
        this.ptr = 0;

        wasm.__wbg_transactionbuildersetios_free(ptr);
    }
    /**
    * @param {Inputs} inputs
    * @param {Outputs} outputs
    * @returns {TransactionBuilderSetWitness}
    */
    set_ios(inputs, outputs) {
        const ptr = this.ptr;
        this.ptr = 0;
        _assertClass(inputs, Inputs);
        _assertClass(outputs, Outputs);
        const ret = wasm.transactionbuildersetios_set_ios(ptr, inputs.ptr, outputs.ptr);
        return TransactionBuilderSetWitness.__wrap(ret);
    }
}
module.exports.TransactionBuilderSetIOs = TransactionBuilderSetIOs;
/**
*/
class TransactionBuilderSetWitness {

    static __wrap(ptr) {
        const obj = Object.create(TransactionBuilderSetWitness.prototype);
        obj.ptr = ptr;

        return obj;
    }

    free() {
        const ptr = this.ptr;
        this.ptr = 0;

        wasm.__wbg_transactionbuildersetwitness_free(ptr);
    }
    /**
    * @returns {TransactionSignDataHash}
    */
    get_auth_data_for_witness() {
        const ret = wasm.transactionbuildersetwitness_get_auth_data_for_witness(this.ptr);
        return TransactionSignDataHash.__wrap(ret);
    }
    /**
    * @param {Witnesses} witnesses
    * @returns {TransactionBuilderSetAuthData}
    */
    set_witnesses(witnesses) {
        const ptr = this.ptr;
        this.ptr = 0;
        _assertClass(witnesses, Witnesses);
        const ret = wasm.transactionbuildersetwitness_set_witnesses(ptr, witnesses.ptr);
        return TransactionBuilderSetAuthData.__wrap(ret);
    }
}
module.exports.TransactionBuilderSetWitness = TransactionBuilderSetWitness;
/**
* Type for representing the hash of a Transaction, necessary for signing it
*/
class TransactionSignDataHash {

    static __wrap(ptr) {
        const obj = Object.create(TransactionSignDataHash.prototype);
        obj.ptr = ptr;

        return obj;
    }

    free() {
        const ptr = this.ptr;
        this.ptr = 0;

        wasm.__wbg_transactionsigndatahash_free(ptr);
    }
    /**
    * @param {Uint8Array} bytes
    * @returns {TransactionSignDataHash}
    */
    static from_bytes(bytes) {
        const ret = wasm.transactionsigndatahash_from_bytes(passArray8ToWasm(bytes), WASM_VECTOR_LEN);
        return TransactionSignDataHash.__wrap(ret);
    }
    /**
    * @param {string} input
    * @returns {TransactionSignDataHash}
    */
    static from_hex(input) {
        const ret = wasm.transactionsigndatahash_from_hex(passStringToWasm(input), WASM_VECTOR_LEN);
        return TransactionSignDataHash.__wrap(ret);
    }
    /**
    * @returns {Uint8Array}
    */
    as_bytes() {
        const retptr = 8;
        const ret = wasm.transactionsigndatahash_as_bytes(retptr, this.ptr);
        const memi32 = getInt32Memory();
        const v0 = getArrayU8FromWasm(memi32[retptr / 4 + 0], memi32[retptr / 4 + 1]).slice();
        wasm.__wbindgen_free(memi32[retptr / 4 + 0], memi32[retptr / 4 + 1] * 1);
        return v0;
    }
}
module.exports.TransactionSignDataHash = TransactionSignDataHash;
/**
*/
class U128 {

    static __wrap(ptr) {
        const obj = Object.create(U128.prototype);
        obj.ptr = ptr;

        return obj;
    }

    free() {
        const ptr = this.ptr;
        this.ptr = 0;

        wasm.__wbg_u128_free(ptr);
    }
    /**
    * @param {any} bytes
    * @returns {U128}
    */
    static from_be_bytes(bytes) {
        const ret = wasm.u128_from_be_bytes(addHeapObject(bytes));
        return U128.__wrap(ret);
    }
    /**
    * @param {any} bytes
    * @returns {U128}
    */
    static from_le_bytes(bytes) {
        const ret = wasm.u128_from_le_bytes(addHeapObject(bytes));
        return U128.__wrap(ret);
    }
    /**
    * @param {string} s
    * @returns {U128}
    */
    static from_str(s) {
        const ret = wasm.u128_from_str(passStringToWasm(s), WASM_VECTOR_LEN);
        return U128.__wrap(ret);
    }
    /**
    * @returns {string}
    */
    to_str() {
        const retptr = 8;
        const ret = wasm.u128_to_str(retptr, this.ptr);
        const memi32 = getInt32Memory();
        const v0 = getStringFromWasm(memi32[retptr / 4 + 0], memi32[retptr / 4 + 1]).slice();
        wasm.__wbindgen_free(memi32[retptr / 4 + 0], memi32[retptr / 4 + 1] * 1);
        return v0;
    }
}
module.exports.U128 = U128;
/**
* Unspent transaction pointer. This is composed of:
* * the transaction identifier where the unspent output is (a FragmentId)
* * the output index within the pointed transaction\'s outputs
* * the value we expect to read from this output, this setting is added in order to protect undesired withdrawal
* and to set the actual fee in the transaction.
*/
class UtxoPointer {

    static __wrap(ptr) {
        const obj = Object.create(UtxoPointer.prototype);
        obj.ptr = ptr;

        return obj;
    }

    free() {
        const ptr = this.ptr;
        this.ptr = 0;

        wasm.__wbg_utxopointer_free(ptr);
    }
    /**
    * @param {FragmentId} fragment_id
    * @param {number} output_index
    * @param {Value} value
    * @returns {UtxoPointer}
    */
    static new(fragment_id, output_index, value) {
        _assertClass(fragment_id, FragmentId);
        const ptr0 = fragment_id.ptr;
        fragment_id.ptr = 0;
        _assertClass(value, Value);
        const ptr1 = value.ptr;
        value.ptr = 0;
        const ret = wasm.utxopointer_new(ptr0, output_index, ptr1);
        return UtxoPointer.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    output_index() {
        const ret = wasm.utxopointer_output_index(this.ptr);
        return ret;
    }
    /**
    * @returns {FragmentId}
    */
    fragment_id() {
        const ret = wasm.utxopointer_fragment_id(this.ptr);
        return FragmentId.__wrap(ret);
    }
}
module.exports.UtxoPointer = UtxoPointer;
/**
* Type used for representing certain amount of lovelaces.
* It wraps an unsigned 64 bits number.
* Strings are used for passing to and from javascript,
* as the native javascript Number type can\'t hold the entire u64 range
* and BigInt is not yet implemented in all the browsers
*/
class Value {

    static __wrap(ptr) {
        const obj = Object.create(Value.prototype);
        obj.ptr = ptr;

        return obj;
    }

    free() {
        const ptr = this.ptr;
        this.ptr = 0;

        wasm.__wbg_value_free(ptr);
    }
    /**
    * Parse the given string into a rust u64 numeric type.
    * @param {string} s
    * @returns {Value}
    */
    static from_str(s) {
        const ret = wasm.value_from_str(passStringToWasm(s), WASM_VECTOR_LEN);
        return Value.__wrap(ret);
    }
    /**
    * Return the wrapped u64 formatted as a string.
    * @returns {string}
    */
    to_str() {
        const retptr = 8;
        const ret = wasm.value_to_str(retptr, this.ptr);
        const memi32 = getInt32Memory();
        const v0 = getStringFromWasm(memi32[retptr / 4 + 0], memi32[retptr / 4 + 1]).slice();
        wasm.__wbindgen_free(memi32[retptr / 4 + 0], memi32[retptr / 4 + 1] * 1);
        return v0;
    }
    /**
    * @param {Value} other
    * @returns {Value}
    */
    checked_add(other) {
        _assertClass(other, Value);
        const ret = wasm.value_checked_add(this.ptr, other.ptr);
        return Value.__wrap(ret);
    }
    /**
    * @param {Value} other
    * @returns {Value}
    */
    checked_sub(other) {
        _assertClass(other, Value);
        const ret = wasm.value_checked_sub(this.ptr, other.ptr);
        return Value.__wrap(ret);
    }
}
module.exports.Value = Value;
/**
*/
class VrfPublicKey {

    static __wrap(ptr) {
        const obj = Object.create(VrfPublicKey.prototype);
        obj.ptr = ptr;

        return obj;
    }

    free() {
        const ptr = this.ptr;
        this.ptr = 0;

        wasm.__wbg_vrfpublickey_free(ptr);
    }
    /**
    * @param {string} bech32_str
    * @returns {VrfPublicKey}
    */
    static from_bech32(bech32_str) {
        const ret = wasm.vrfpublickey_from_bech32(passStringToWasm(bech32_str), WASM_VECTOR_LEN);
        return VrfPublicKey.__wrap(ret);
    }
}
module.exports.VrfPublicKey = VrfPublicKey;
/**
* Structure that proofs that certain user agrees with
* some data. This structure is used to sign `Transaction`
* and get `SignedTransaction` out.
*
* It\'s important that witness works with opaque structures
* and may not know the contents of the internal transaction.
*/
class Witness {

    static __wrap(ptr) {
        const obj = Object.create(Witness.prototype);
        obj.ptr = ptr;

        return obj;
    }

    free() {
        const ptr = this.ptr;
        this.ptr = 0;

        wasm.__wbg_witness_free(ptr);
    }
    /**
    * Generate Witness for an utxo-based transaction Input
    * @param {Hash} genesis_hash
    * @param {TransactionSignDataHash} transaction_id
    * @param {PrivateKey} secret_key
    * @returns {Witness}
    */
    static for_utxo(genesis_hash, transaction_id, secret_key) {
        _assertClass(genesis_hash, Hash);
        const ptr0 = genesis_hash.ptr;
        genesis_hash.ptr = 0;
        _assertClass(transaction_id, TransactionSignDataHash);
        const ptr1 = transaction_id.ptr;
        transaction_id.ptr = 0;
        _assertClass(secret_key, PrivateKey);
        const ptr2 = secret_key.ptr;
        secret_key.ptr = 0;
        const ret = wasm.witness_for_utxo(ptr0, ptr1, ptr2);
        return Witness.__wrap(ret);
    }
    /**
    * Generate Witness for an account based transaction Input
    * the account-spending-counter should be incremented on each transaction from this account
    * @param {Hash} genesis_hash
    * @param {TransactionSignDataHash} transaction_id
    * @param {PrivateKey} secret_key
    * @param {SpendingCounter} account_spending_counter
    * @returns {Witness}
    */
    static for_account(genesis_hash, transaction_id, secret_key, account_spending_counter) {
        _assertClass(genesis_hash, Hash);
        const ptr0 = genesis_hash.ptr;
        genesis_hash.ptr = 0;
        _assertClass(transaction_id, TransactionSignDataHash);
        const ptr1 = transaction_id.ptr;
        transaction_id.ptr = 0;
        _assertClass(secret_key, PrivateKey);
        const ptr2 = secret_key.ptr;
        secret_key.ptr = 0;
        _assertClass(account_spending_counter, SpendingCounter);
        const ptr3 = account_spending_counter.ptr;
        account_spending_counter.ptr = 0;
        const ret = wasm.witness_for_account(ptr0, ptr1, ptr2, ptr3);
        return Witness.__wrap(ret);
    }
    /**
    * Get string representation
    * @returns {string}
    */
    to_bech32() {
        const retptr = 8;
        const ret = wasm.witness_to_bech32(retptr, this.ptr);
        const memi32 = getInt32Memory();
        const v0 = getStringFromWasm(memi32[retptr / 4 + 0], memi32[retptr / 4 + 1]).slice();
        wasm.__wbindgen_free(memi32[retptr / 4 + 0], memi32[retptr / 4 + 1] * 1);
        return v0;
    }
}
module.exports.Witness = Witness;
/**
*/
class Witnesses {

    static __wrap(ptr) {
        const obj = Object.create(Witnesses.prototype);
        obj.ptr = ptr;

        return obj;
    }

    free() {
        const ptr = this.ptr;
        this.ptr = 0;

        wasm.__wbg_witnesses_free(ptr);
    }
    /**
    * @returns {Witnesses}
    */
    static new() {
        const ret = wasm.witnesses_new();
        return Witnesses.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    size() {
        const ret = wasm.witnesses_size(this.ptr);
        return ret >>> 0;
    }
    /**
    * @param {number} index
    * @returns {Witness}
    */
    get(index) {
        const ret = wasm.witnesses_get(this.ptr, index);
        return Witness.__wrap(ret);
    }
    /**
    * @param {Witness} item
    */
    add(item) {
        _assertClass(item, Witness);
        const ptr0 = item.ptr;
        item.ptr = 0;
        wasm.witnesses_add(this.ptr, ptr0);
    }
}
module.exports.Witnesses = Witnesses;

module.exports.__wbindgen_string_new = function(arg0, arg1) {
    const ret = getStringFromWasm(arg0, arg1);
    return addHeapObject(ret);
};

module.exports.__wbindgen_object_drop_ref = function(arg0) {
    takeObject(arg0);
};

module.exports.__wbindgen_json_serialize = function(arg0, arg1) {
    const obj = getObject(arg1);
    const ret = JSON.stringify(obj === undefined ? null : obj);
    const ret0 = passStringToWasm(ret);
    const ret1 = WASM_VECTOR_LEN;
    getInt32Memory()[arg0 / 4 + 0] = ret0;
    getInt32Memory()[arg0 / 4 + 1] = ret1;
};

module.exports.__wbindgen_is_undefined = function(arg0) {
    const ret = getObject(arg0) === undefined;
    return ret;
};

module.exports.__wbg_buffer_cdcb54e9871fd20a = function(arg0) {
    const ret = getObject(arg0).buffer;
    return addHeapObject(ret);
};

module.exports.__wbg_length_deb426bb35063224 = function(arg0) {
    const ret = getObject(arg0).length;
    return ret;
};

module.exports.__wbg_new_8f74bcd603e235c0 = function(arg0) {
    const ret = new Uint8Array(getObject(arg0));
    return addHeapObject(ret);
};

module.exports.__wbg_set_662b22f1b4008ab7 = function(arg0, arg1, arg2) {
    getObject(arg0).set(getObject(arg1), arg2 >>> 0);
};

module.exports.__wbg_new_3a746f2619705add = function(arg0, arg1) {
    const ret = new Function(getStringFromWasm(arg0, arg1));
    return addHeapObject(ret);
};

module.exports.__wbg_call_f54d3a6dadb199ca = function(arg0, arg1) {
    const ret = getObject(arg0).call(getObject(arg1));
    return addHeapObject(ret);
};

module.exports.__wbindgen_jsval_eq = function(arg0, arg1) {
    const ret = getObject(arg0) === getObject(arg1);
    return ret;
};

module.exports.__wbg_self_ac379e780a0d8b94 = function(arg0) {
    const ret = getObject(arg0).self;
    return addHeapObject(ret);
};

module.exports.__wbg_crypto_1e4302b85d4f64a2 = function(arg0) {
    const ret = getObject(arg0).crypto;
    return addHeapObject(ret);
};

module.exports.__wbg_getRandomValues_1b4ba144162a5c9e = function(arg0) {
    const ret = getObject(arg0).getRandomValues;
    return addHeapObject(ret);
};

module.exports.__wbg_require_6461b1e9a0d7c34a = function(arg0, arg1) {
    const ret = require(getStringFromWasm(arg0, arg1));
    return addHeapObject(ret);
};

module.exports.__wbg_randomFillSync_1b52c8482374c55b = function(arg0, arg1, arg2) {
    getObject(arg0).randomFillSync(getArrayU8FromWasm(arg1, arg2));
};

module.exports.__wbg_getRandomValues_1ef11e888e5228e9 = function(arg0, arg1, arg2) {
    getObject(arg0).getRandomValues(getArrayU8FromWasm(arg1, arg2));
};

module.exports.__wbindgen_throw = function(arg0, arg1) {
    throw new Error(getStringFromWasm(arg0, arg1));
};

module.exports.__wbindgen_rethrow = function(arg0) {
    throw takeObject(arg0);
};

module.exports.__wbindgen_memory = function() {
    const ret = wasm.memory;
    return addHeapObject(ret);
};
wasm = require('./js_chain_libs_node_bg');

